<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>word_proximity. qdap 1.3.3</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="">

<link href="css/bootstrap.css" rel="stylesheet">
<link href="css/bootstrap-responsive.css" rel="stylesheet">
<link href="css/highlight.css" rel="stylesheet">
<link href="css/staticdocs.css" rel="stylesheet">

<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
  </head>

  <body>
    <div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="brand" href="#">qdap 1.3.3</a>
      <div class="nav">
        <ul class="nav">
          <li><a href="index.html"><i class="icon-home icon-white"></i> Index</a></li>
        </ul>
      </div>
    </div>
  </div>
</div>

    <div class="container">
      <header>
        
      </header>
      
      <h1>Proximity Matrix Between Words</h1>

<div class="row">
  <div class="span8">
    <h2>Usage</h2>
    <pre><div>word_proximity(text.var, terms, grouping.var&nbsp;=&nbsp;NULL, parallel&nbsp;=&nbsp;TRUE, cores&nbsp;=&nbsp;parallel::detectCores()/2)</div>
<div>weight(x, type&nbsp;=&nbsp;"scale", ...)</div>
<div>"weight"(x, type&nbsp;=&nbsp;"scale", ...)</div></pre>
    
    <h2>Arguments</h2>
    <dl>
      <dt>text.var</dt>
      <dd>The text variable.</dd>
      <dt>terms</dt>
      <dd>A vector of quoted terms.</dd>
      <dt>grouping.var</dt>
      <dd>The grouping variables.  Default
  <code>NULL</code> generates one word list for all text.  Also
  takes a single grouping variable or a list of 1 or more
  grouping variables.</dd>
      <dt>parallel</dt>
      <dd>logical.  If <code>TRUE</code> attempts to run
  the function on multiple cores.  Note that this may not
  mean a speed boost if you have one core or if the data
  set is smaller as the cluster takes time to create.</dd>
      <dt>cores</dt>
      <dd>The number of cores to use if <code>parallel
  = TRUE</code>.  Default is half the number of available cores.</dd>
      <dt>x</dt>
      <dd>An object to be weighted.</dd>
      <dt>type</dt>
      <dd>A weighting type of: c(<code>"scale_log"</code>,
  <code>"scale"</code>, <code>"rev_scale"</code>,
  <code>"rev_scale_log"</code>, <code>"log"</code>, <code>"sqrt"</code>,
  <code>"scale_sqrt"</code>, <code>"rev_sqrt"</code>,
  <code>"rev_scale_sqrt"</code>).  The weight type section name
  (i.e. <code>A_B_C</code> where <code>A</code>, <code>B</code>, and <code>C</code>
  are sections) determines what action will occur.
  <code>log</code> will use <code><a href='http://www.inside-r.org/r-doc/base/Log'>log</a></code>, <code>sqrt</code>
  will use <code><a href='http://www.inside-r.org/r-doc/base/MathFun'>sqrt</a></code>, <code>scale</code> will
  standardize the values.  <code>rev</code> will multiply by -1
  to give the inverse sign.  This enables a comparison
  similar to correlations rather than distance.</dd>
      <dt>...</dt>
      <dd>ignored.</dd>
    </dl>
    
    <div class="Value">
      <h2>Value</h2>
      
      <p>Returns a list of matrices of proximity measures in the
unit of average sentences between words (defaults to
scaled).</p>
  
      <p>Returns a weighted list of matrices.</p>
  
    </div>

    <div class="Description">
      <h2>Description</h2>
      
      <p>Generate proximity measures to ascertain a mean distance
measure between word uses.</p>
  
      <p>Weight a word_proximity object.</p>
  
      <p>word_proximity Method for weight</p>
  
    </div>

    <div class="Details">
      <h2>Details</h2>
      
      <p>Note that row names are the first word and column names are
the second comparison word. The values for Word A compared
to Word B will not be the same as Word B compared to Word
A. This is because, unlike a true distance measure,
<code>word_proximity</code>'s matrix is asymmetrical.
<code>word_proximity</code> computes the distance by taking each
sentence position for Word A and comparing it to the
nearest sentence location for Word B.</p>
  
    </div>

    <div class="Note">
      <h2>Note</h2>
      
      <p>The match.terms is character sensitive.  Spacing is an
important way to grab specific words and requires careful
thought.  Using "read" will find the words "bread", "read"
"reading", and "ready".  If you want to search for just the
word "read" you'd supply a vector of c(" read ", " reads",
" reading", " reader").</p>
  
      <p>A constant of .000000000001 is added to each element when
log is used to deal with the problem of <code>log(0)</code>.</p>
  
    </div>
    
    <h2 id="examples">Examples</h2>
    <pre class="examples"><div class='input'>## &lt;strong&gt;Not run&lt;/strong&gt;: # wrds &lt;- word_list(pres_debates2012$dialogue,#     stopwords = c(&quot;it&#39;s&quot;, &quot;that&#39;s&quot;, Top200Words))# wrds2 &lt;- tolower(sort(wrds$rfswl[[1]][, 1]))# # (x &lt;- with(pres_debates2012, word_proximity(dialogue, wrds2)))# plot(x)# plot(weight(x))# plot(weight(x, &quot;rev_scale_log&quot;))# # (x2 &lt;- with(pres_debates2012, word_proximity(dialogue, wrds2, person)))# # ## The spaces around `terms` are important# (x3 &lt;- with(DATA, word_proximity(state, spaste(qcv(the, i)))))# (x4 &lt;- with(DATA, word_proximity(state, qcv(the, i))))# ## &lt;strong&gt;End(Not run)&lt;/strong&gt;</div></pre>
  </div>
  <div class="span4">
    <!-- <ul>
      <li>weight</li><li>weight.word_proximity</li><li>word_proximity</li>
    </ul>
    <ul>
      
    </ul> -->
      
    <h2>See also</h2>
    
<code>word_proximity</code>

        
  </div>
</div>
      
      <footer>
      <p class="pull-right"><a href="#">Back to top</a></p>
<p>Built by <a href="https://github.com/hadley/staticdocs">staticdocs</a>. Styled with <a href="http://twitter.github.com/bootstrap">bootstrap</a>.</p>
      </footer>
    </div>
  </body>
</html>