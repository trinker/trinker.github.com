<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>polarity. qdap 1.3.0</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="">

<link href="css/bootstrap.css" rel="stylesheet">
<link href="css/bootstrap-responsive.css" rel="stylesheet">
<link href="css/highlight.css" rel="stylesheet">
<link href="css/staticdocs.css" rel="stylesheet">

<!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
  </head>

  <body>
    <div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="brand" href="#">qdap 1.3.0</a>
      <div class="nav">
        <ul class="nav">
          <li><a href="index.html"><i class="icon-home icon-white"></i> Index</a></li>
        </ul>
      </div>
    </div>
  </div>
</div>

    <div class="container">
      <header>
        
      </header>
      
      <h1>Polarity Score (Sentiment Analysis)</h1>

<div class="row">
  <div class="span8">
    <h2>Usage</h2>
    <pre>polarity(text.var, grouping.var = NULL, polarity.frame = qdapDictionaries::env.pol, 
  negators = qdapDictionaries::negation.words, amplifiers = qdapDictionaries::amplification.words, 
      deamplifiers = qdapDictionaries::deamplification.words, question.weight = 0, 
      amplifier.weight = 0.8, n.before = 4, n.after = 2, rm.incomplete = FALSE, digits = 3, 
      ...)

polarity_frame(positives, negatives, pos.weights = 1, neg.weights = -1, envir = TRUE)</pre>
    
    <h2>Arguments</h2>
    <dl>
      <dt>text.var</dt>
      <dd>The text variable.</dd>
      <dt>grouping.var</dt>
      <dd>The grouping variables.  Default
  <code>NULL</code> generates one word list for all text.  Also
  takes a single grouping variable or a list of 1 or more
  grouping variables.</dd>
      <dt>polarity.frame</dt>
      <dd>A dataframe or environment
  containing a dataframe of positive/negative words and
  weights.</dd>
      <dt>negators</dt>
      <dd>A character vector of terms reversing the
  intent of a positive or negative word.</dd>
      <dt>amplifiers</dt>
      <dd>A character vector of terms that
  increase the intensity of a positive or negative word.</dd>
      <dt>deamplifiers</dt>
      <dd>A character vector of terms that
  decrease the intensity of a positive or negative word.</dd>
      <dt>question.weight</dt>
      <dd>The weighting of questions (values
  from 0 to 1). Default 0 corresponds with the belief that
  questions (pure questions) are not polarized.  A weight
  may be applied based on the evidence that the questions
  function with polarity.</dd>
      <dt>amplifier.weight</dt>
      <dd>The weight to apply to
  amplifiers/deamplifiers (values from 0 to 1).  This value
  will multiply the polarized terms by 1 + this value.</dd>
      <dt>n.before</dt>
      <dd>The number of words to consider as
  valence shifters before the polarized word.</dd>
      <dt>n.after</dt>
      <dd>The number of words to consider as valence
  shifters after the polarized word.</dd>
      <dt>rm.incomplete</dt>
      <dd>logical.  If <code>TRUE</code> text rows
  ending with qdap's incomplete sentence end mark
  (<code>|</code>) will be removed from the analysis.</dd>
      <dt>digits</dt>
      <dd>Integer; number of decimal places to round
  when printing.</dd>
      <dt>...</dt>
      <dd>Other arguments supplied to
  <code>strip</code>.</dd>
      <dt>positives</dt>
      <dd>A character vector of positive words.</dd>
      <dt>negatives</dt>
      <dd>A character vector of negative words.</dd>
      <dt>pos.weights</dt>
      <dd>A vector of weights to weight each
  positive word by. Length must be equal to length of
  <code>postives</code> or length 1 (if 1 weight will be
  recycled).</dd>
      <dt>neg.weights</dt>
      <dd>A vector of weights to weight each
  negative word by. Length must be equal to length of
  <code>negatives</code> or length 1 (if 1 weight will be
  recycled).</dd>
      <dt>envir</dt>
      <dd>logical.  If <code>TRUE</code> a lookup table (a
  dataframe within an environment) is produced rather than
  a data.frame.</dd>
    </dl>
    
    <div class="Value">
      <h2>Value</h2>
      
      <p>Returns a list of: allA dataframe of scores per row
with: <ul>
<li> group.var - the grouping variable
</li>
<li> wc - word count </li>
<li> polarity - sentence polarity
score </li>
<li> pos.words - words considered positive </li>
<li>
neg.words - words considered negative </li>
<li> text.var - the
text variable</li>
</ul>
  groupA dataframe with the average
polarity score by grouping variable: <ul>
<li>
group.var - the grouping variable </li>
<li> total.sentences -
Total sentences spoken.  </li>
<li> total.words - Total words
used.  </li>
<li> ave.polarity - The sum of all polarity scores
for that group divided by number of sentences spoken.
</li>
<li> sd.polarity - The standard deviation of that group's
sentence level polarity scores.  </li>
<li> stan.mean.polarity -
A standardized polarity score calculated by taking the
average polarity score for a group divided by the standard
deviation.</li>
</ul>
  digitsinteger value od number of
digits to display; mostly internal use</p>
  
    </div>

    <div class="Description">
      <h2>Description</h2>
      
      <p><code>polarity</code> - Approximate the sentiment (polarity) of
text by grouping variable(s).</p>
  
      <p><code>polarity_frame</code> - Generate a polarity lookup
environment or data.frame for use with the
<code>polarity.frame</code> argument in the <code>polarity</code>
function.</p>
  
    </div>

    <div class="Details">
      <h2>Details</h2>
      
      <p>The equation used by the algorithm to assign value to
polarity of each sentence fist utilizes the sentiment
dictionary (Hu and Liu, 2004) to tag polarized words.  A
context cluster (<code class = 'eq'>x_i^{T}</code>) of words is pulled from
around this polarized word (default 4 words before and two
words after) to be considered as valence shifters.  The
words in this context cluster are tagged as neutral
(<code class = 'eq'>x_i^{0}</code>), negator (<code class = 'eq'>x_i^{N}</code>), amplifier
(<code class = 'eq'>x_i^{a}</code>), or de-amplifier (<code class = 'eq'>x_i^{d}</code>). Neutral
words hold no value in the equation but do affect word
count (<code class = 'eq'>n</code>).  Each polarized word is then weighted
<code class = 'eq'>w</code> based on the weights from the <code>polarity.frame</code>
argument and then further weighted by the number and
position of the valence shifters directly surrounding the
positive or negative word.  The researcher may provide a
weight <code class = 'eq'>c</code> to be utilized with amplifiers/de-amplifiers
(default is .8; deamplifier weight is constrained to -1
lower bound).  Last, these context cluster (<code class = 'eq'>x_i^{T}</code>)
are summed and divided by the square root of the word count
(<code class = 'eq'>\sqrt{n}</code>) yielding an unbounded polarity score
(<code class = 'eq'>\delta</code>).  Note that context clusters containing a
comma before the polarized word will only consider words
found after the comma.</p>
  
      <p><pre class = 'eq'>\delta=\frac{x_i^T}{\sqrt{n}}</code></p>
  
      <p>Where:</p>
  
      <p><pre class = 'eq'>x_i^T=\sum{((1 + c(x_i^{A} - x_i^{D}))\cdot
w(-1)^{\sum{x_i^{N}}})}</code></p>
  
      <p><pre class = 'eq'>x_i^{A}=\sum{(w_{neg}\cdot x_i^{a})}</code></p>
  
      <p><pre class = 'eq'>x_{i}^D=\left\{\begin{array}{cc} x_{i}^D & x_{i}^D
\geq -1 \\ -1 & x_{i}^D < -1 \end{array}\right.</code></p>
  
      <p><pre class = 'eq'>x_i^{D}=\sum{(- w_{neg}\cdot x_i^{a} + x_i^{d})}</code></p>
  
      <p><pre class = 'eq'>w_{neg}=\left\{\begin{array}{cc} 1 & \sum{x_i^{N}}
\bmod {2} >0 \\ 0 & \sum{x_i^{N}} \bmod {2} =0
\end{array}\right.</code></p>
  
    </div>

    <div class="Note">
      <h2>Note</h2>
      
      <p>The polarity score is dependent upon the polarity
dictionary used. This function defaults to the word
polarity dictionary used by Hu, M., & Liu, B. (2004),
however, this may not be appropriate for the context of
children in a classroom.  The user may (is encouraged) to
provide/augment the dictionary (see the
<code>polarity_frame</code> function).  For instance the word
"sick" in a high school setting may mean that something is
good, whereas "sick" used by a typical adult indicates
something is not right or negative connotation.</p>
  
      <p>Also note that <code>polarity</code> assumes you've
run <code>sentSplit</code>.</p>
  
    </div>

    <div class="References">
      <h2>References</h2>
      
      <p>Hu, M., & Liu, B. (2004). Mining opinion features in
customer reviews. National Conference on Artificial
Intelligence.</p>
  
      <p><a href = 'http://www.slideshare.net/jeffreybreen/r-by-example-mining-twitter-for'>http://www.slideshare.net/jeffreybreen/r-by-example-mining-twitter-for</a></p>
  
    </div>
      </div>
  <div class="span4">
    <!-- <ul>
      <li>polarity</li><li>polarity_frame</li>
    </ul>
    <ul>
      <li>polarity</li><li>sentiment,</li>
    </ul> -->
      
    <h2>See also</h2>
    
<a href = 'https://github.com/trestletech/Sermon-Sentiment-Analysis'>https://github.com/trestletech/Sermon-Sentiment-Analysis</a>

        
  </div>
</div>
      
      <footer>
      <p class="pull-right"><a href="#">Back to top</a></p>
<p>Built by <a href="https://github.com/hadley/staticdocs">staticdocs</a>. Styled with <a href="http://twitter.github.com/bootstrap">bootstrap</a>.</p>
      </footer>
    </div>
  </body>
</html>